package chap03.lecture.binary;

public class ShiftOperator {
	public static void main(String[] args) {
		// << >> >>> 비트이동연산자
		int i = 10;
		System.out.println( i << 1);
		
		// 10 : 0000 0000 0000 0000 0000 0000 0000 1010
		// <<1: 0000 0000 0000 0000 0000 0000 0000 10100 으로 밀림
		// 1이 있는 자리가 왼쪽으로 한칸씩 이동해서 20 4+16 
		// 왼쪽으로 2번 shift 하면
		// 원래수에서 *2 *2 해서 40이 됨 한칸씩 갈때마다 *2해주면됨
		
		// 오른쪽 shift
		System.out.println(i >> 1);
		// 10: 0000 0000 0000 0000 0000 0000 0000 1010
		// >>1  0000 0000 0000 0000 0000 0000 0000 1010 넘어간건 지워지고 남은건 맨앞의비트와 같은비트로 채워짐(0이니까 0)
		// 맨앞의 비트와 같은비트로 채워지므로 맨앞 비트가 1이던 음수라면 1로 채워짐
		// >>1 00000 0000 0000 0000 0000 0000 0000 101 해서 5가됨 (나누기 2한것과 같음)
		System.out.println(i >>2); // 2.5인데 소숫점 날아감
		
		i = -10;
		System.out.println( i << 1); // 곱하기 2한것과 결과가 같음 -20
		System.out.println(i >> 1); // 나누기 2한것과 결과 같음 -5 
		
		// 근데 최상위 비트를 앞의 비트를 항상 0으로 채우고 싶다면 >>>
		// -10  : ‭1111 1111 1111 1111 1111 1111 1111 0110‬‬
		// >>>1 : 01111 1111 1111 1111 1111 1111 1111 011‬ 오른쪽으로 한칸 이동시키되 맨앞의비트를 같게안하고 항상 0으로 
		// 양수로 바뀜 
		System.out.println(i >>> 1 ); // 2147483643 가 나옴 
	}
}
